<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>JekyllChess PGN App</title>

<!-- jQuery (required by your setup) -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<!-- Chess libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">

<style>
* { box-sizing: border-box; }

html, body {
  margin: 0;
  height: 100%;
  background: #0f1115;
  color: #e6e6e6;
  font-family: system-ui, -apple-system, sans-serif;
}

/* ---------- TOP BAR ---------- */
.topbar {
  min-height: 52px;
  padding: 0 14px;
  display: flex;
  align-items: center;
  gap: 10px;
  background: #171a21;
  border-bottom: 1px solid #222;
}

.brand {
  display: flex;
  align-items: center;
  gap: 10px;
}

.brand img {
  width: 22px;
  height: 22px;
  filter: invert(1);
}

.title { font-weight: 700; }

/* ---------- LAYOUT ---------- */
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

/* ---------- BOARD ---------- */
.board-wrap { padding: 12px; }
#board { width: min(92vw, 560px); margin: 0 auto; }

/* ---------- CONTROLS ---------- */
.controls {
  padding: 0 12px 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.controls-row { display: flex; gap: 6px; }

.controls button {
  flex: 1;
  padding: 10px 0;
  border: none;
  border-radius: 10px;
  background: #1f2430;
  color: #ddd;
  font-size: 15px;
}

.controls button:disabled { opacity: .4; }

/* ---------- RIGHT PANE ---------- */
.pane { display: none; }
.pane.active { display: block; }

/* ---------- TABS ---------- */
.tabs {
  display: flex;
  border-bottom: 1px solid #222;
}

.tab {
  flex: 1;
  text-align: center;
  padding: 10px;
  cursor: pointer;
  background: #141820;
}

.tab.active {
  background: #1f2430;
  font-weight: 600;
}

/* ---------- MOVES ---------- */
.moves {
  padding: 16px;
  overflow-y: auto;
  line-height: 2.2;
  font-size: 18px;
}

.move {
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 6px;
  display: inline-block;
}

.move.active { background: #3a7afe; color: #fff; }

.comment {
  margin: 4px 0 10px 20px;
  padding-left: 8px;
  border-left: 3px solid #3a7afe;
  font-size: 15px;
  color: #cfd6ff;
}

.add-comment-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  margin-left: 6px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  background: #1f2430;
  color: #ddd;
  font-size: 18px;
  line-height: 0;
}
.add-comment-btn:hover { background: #2a3150; }

/* ---------- VARIATIONS ---------- */
.variation {
  margin: 6px 0 12px 28px;
  padding-left: 10px;
  border-left: 2px dashed #444;
  font-size: 16px;
  opacity: .92;
}

.variation .move {
  background: #1a1f2b;
  margin-right: 4px;
}

/* ---------- PGN ---------- */
.pgn-wrap { padding: 12px; }

textarea {
  width: 100%;
  height: 320px;
  background: #0f1115;
  color: #e6e6e6;
  border: 1px solid #222;
  border-radius: 8px;
  padding: 10px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 14px;
  resize: vertical;
}

.pgn-actions {
  margin-top: 10px;
  display: flex;
  gap: 8px;
}

.pgn-actions button, .pgn-actions select {
  flex: 1;
  padding: 10px 10px;
  border: 1px solid #222;
  border-radius: 10px;
  background: #1f2430;
  color: #ddd;
  font-size: 14px;
}

.pgn-actions select { appearance: none; }

.pgn-actions .btn {
  border: none;
  cursor: pointer;
}

/* ---------- DESKTOP ---------- */
@media (min-width: 900px) {
  .main { display: grid; grid-template-columns: 560px 1fr; }
}
</style>
</head>

<body>

<div class="app">
  <div class="topbar">
    <div class="brand">
      <img src="https://jekyllchess.github.io/assets/favicon.png" alt="">
      <div class="title">JekyllChess PGN App</div>
    </div>
  </div>

  <div class="main">
    <!-- LEFT -->
    <div>
      <div class="board-wrap">
        <div id="board"></div>
      </div>

      <!-- 4 navigation buttons -->
      <div class="controls">
        <div class="controls-row">
          <button id="btnStart" title="Go to start (Home)">⏮</button>
          <button id="btnPrev"  title="Previous move (←)">◀</button>
          <button id="btnNext"  title="Next move (→)">▶</button>
          <button id="btnEnd"   title="Go to end (End)">⏭</button>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div>
      <div class="tabs">
        <div class="tab active" data-tab="moves">Moves</div>
        <div class="tab" data-tab="pgn">PGN text editor</div>
      </div>

      <div id="movesPane" class="pane active">
        <div class="moves" id="moves"></div>
      </div>

      <div id="pgnPane" class="pane">
        <div class="pgn-wrap">
          <div class="pgn-actions">
            <select id="tagSelect" title="Add a PGN tag"></select>
            <button class="btn" id="btnAddTag">Add header</button>
          </div>

          <textarea id="pgnText" spellcheck="false"></textarea>

          <div class="pgn-actions">
            <button class="btn" id="btnCopyPGN">Copy PGN</button>
            <button class="btn" id="btnCopyFEN">Copy FEN</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const FIG = { K:"♔", Q:"♕", R:"♖", B:"♗", N:"♘" };

  // --- "All valid PGN headers" dropdown (PGN tag names are extensible; this list includes
  // STR + commonly used supplemental tags from the PGN ecosystem/spec supplements.) ---
  const TAG_NAME_OPTIONS = [
    // Seven Tag Roster (STR)
    "Event","Site","Date","Round","White","Black","Result",
    // Setup / position
    "SetUp","FEN",
    // Identification / metadata
    "EventDate","UTCDate","UTCTime","Time","TimeControl","Termination","Mode","PlyCount","Annotator",
    "ECO","Opening","Variation",
    // Ratings / titles / IDs / teams
    "WhiteElo","BlackElo","WhiteTitle","BlackTitle","WhiteFideId","BlackFideId",
    "WhiteTeam","BlackTeam","Board","Section","Stage",
    // Misc commonly seen
    "WhiteUSCF","BlackUSCF","WhiteNA","BlackNA","WhiteType","BlackType","Source","SourceDate"
  ];

  function todayYYYYMMDD() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}.${m}.${day}`;
  }

  const DEFAULT_TAGS = {
    Event: "Casual Game",
    Site: "Online",
    Date: todayYYYYMMDD(),
    Round: "-",
    White: "White",
    Black: "Black",
    Result: "*"
  };

  function normalizeTags(tagObj) {
    const t = { ...DEFAULT_TAGS, ...tagObj };
    if (!/^\d{4}\.\d{2}\.\d{2}$/.test(t.Date) && t.Date !== "????.??.??") t.Date = DEFAULT_TAGS.Date;
    if (!/^(1-0|0-1|1\/2-1\/2|\*)$/.test(t.Result)) t.Result = "*";
    return t;
  }

  function parseTagsFromPGN(pgn) {
    const tags = {};
    const tagRe = /^\s*\[([A-Za-z0-9_]+)\s+"([^"]*)"\]\s*$/gm;
    let m;
    while ((m = tagRe.exec(pgn)) !== null) tags[m[1]] = m[2];
    return tags;
  }

  function stripTagSection(pgn) {
    return pgn.replace(/^\s*\[[^\]]+\]\s*$/gm, "").trim();
  }

  function buildTagSection(tags) {
    const t = normalizeTags(tags);
    const order = ["Event","Site","Date","Round","White","Black","Result"];
    const lines = [];

    // STR first (in order)
    order.forEach(k => lines.push(`[${k} "${t[k] ?? ""}"]`));

    // Non-STR tags (ASCII order)
    const extras = Object.keys(t)
      .filter(k => !order.includes(k))
      .sort((a,b)=>a.localeCompare(b));

    extras.forEach(k => lines.push(`[${k} "${t[k] ?? ""}"]`));
    return lines.join("\n");
  }

  // --- Internal model (mainline + simple variations + comments) ---
  // modelMainSAN: SAN array for main line
  // variationsByPly: plyIndex -> [{id, san:[]}, ...] (branch occurs AFTER plyIndex)
  // commentsByPly: plyIndex -> string (comment AFTER that move)
  const variationsByPly = new Map();
  const commentsByPly = new Map();
  let varSeq = 1;

  let tags = normalizeTags({});

  // Navigation state on MAINLINE (plies)
  let navPly = -1;      // -1 = initial position
  let activeVar = null; // { fromPly, varId, plyInVar } or null

  let modelMainSAN = [];
  const chessMain = new Chess(); // maintained at END of mainline for convenience

  // Track current board position FEN for Copy FEN
  let currentBoardFEN = "start";

  // --- DOM ---
  const movesDiv = document.getElementById("moves");
  const pgnText = document.getElementById("pgnText");
  const tagSelect = document.getElementById("tagSelect");

  const btnStart = document.getElementById("btnStart");
  const btnPrev  = document.getElementById("btnPrev");
  const btnNext  = document.getElementById("btnNext");
  const btnEnd   = document.getElementById("btnEnd");

  const btnCopyPGN = document.getElementById("btnCopyPGN");
  const btnCopyFEN = document.getElementById("btnCopyFEN");
  const btnAddTag  = document.getElementById("btnAddTag");

  // Populate dropdown
  (function initTagDropdown(){
    const uniq = Array.from(new Set(TAG_NAME_OPTIONS));
    uniq.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      tagSelect.appendChild(opt);
    });
  })();

  // --- Board init ---
  const board = Chessboard("board", {
    position: "start",
    draggable: true,
    pieceTheme: "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png",
    onDrop
  });

  function setBoard(fen, animate) {
    // Animate only for navigation (buttons/keyboard/move-list clicks), NOT for user move entry.
    currentBoardFEN = fen;
    board.position(fen, !!animate);
  }

  // --- Helpers ---
  function figSAN(s) {
    return s.replace(/^[KQRBN]/, p => FIG[p])
            .replace(/=([QRBN])/g, (_,p)=>"="+FIG[p]);
  }

  function setNavButtonsEnabled(hasMoves) {
    [btnStart, btnPrev, btnNext, btnEnd].forEach(b => b.disabled = !hasMoves);
  }

  function writeClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) return navigator.clipboard.writeText(text);
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  // Compute FEN at main ply
  function fenAtMainPly(ply) {
    const c = new Chess();
    for (let i = 0; i <= ply; i++) c.move(modelMainSAN[i]);
    return c.fen();
  }

  // --- Movetext building (includes comments + variations) ---
  function buildMovetextFromModel() {
    let out = [];
    for (let i = 0; i < modelMainSAN.length; i++) {
      const isWhite = (i % 2 === 0);
      if (isWhite) out.push(`${Math.floor(i/2)+1}.`);

      out.push(modelMainSAN[i]);

      const cm = commentsByPly.get(i);
      if (cm && cm.trim()) out.push(`{${cm.replace(/\}/g, "")}}`);

      const vars = variationsByPly.get(i);
      if (vars && vars.length) {
        vars.forEach(v => {
          const plyNo = i + 1;
          const moveNo = Math.floor(plyNo/2) + 1;
          const startsBlack = (plyNo % 2 === 1);
          const prefix = startsBlack ? `${moveNo}...` : `${moveNo}.`;
          out.push("(" + prefix + " " + v.san.join(" ") + ")");
        });
      }
    }

    const res = normalizeTags(tags).Result;
    if (out.length === 0) return res;
    return out.join(" ").trim() + " " + res;
  }

  function syncTextareaFromModel() {
    const tagSection = buildTagSection(tags);
    const movetext = buildMovetextFromModel();
    pgnText.value = tagSection + "\n\n" + movetext;
  }

  // --- Load from textarea (best-effort variations; comments via chess.js) ---
  function extractVariationsBestEffort(movetext) {
    let depth = 0, main = "", buf = "";
    const blocks = [];
    for (const ch of movetext) {
      if (ch === "(") {
        if (++depth === 1) buf = "";
        else buf += ch;
      } else if (ch === ")") {
        if (--depth === 0) blocks.push(buf.trim());
        else buf += ch;
      } else {
        depth ? (buf += ch) : (main += ch);
      }
    }

    const c = new Chess();
    c.load_pgn(main, { sloppy:true });
    const mainHist = c.history(); // SAN
    const attachTo = Math.max(-1, mainHist.length - 1);

    const attached = new Map();
    blocks.forEach(raw => {
      const cleaned = raw.replace(/\b\d+\.(\.\.)?\s*/g, "").trim();
      if (!cleaned) return;
      const sanTokens = cleaned.split(/\s+/).filter(Boolean);
      const ply = attachTo;
      if (!attached.has(ply)) attached.set(ply, []);
      attached.get(ply).push(sanTokens);
    });

    return { mainText: main, attached };
  }

  function loadFromTextarea() {
    const full = pgnText.value || "";
    tags = normalizeTags(parseTagsFromPGN(full));
    const movetextRaw = stripTagSection(full);

    const { mainText, attached } = extractVariationsBestEffort(movetextRaw);

    // Parse mainline + comments with chess.js (it supports {...} comments)
    const c = new Chess();
    c.load_pgn(buildTagSection(tags) + "\n\n" + mainText.trim(), { sloppy:true });

    modelMainSAN = c.history(); // SAN only
    commentsByPly.clear();
    const verbose = c.history({ verbose:true });
    verbose.forEach((m, i) => {
      if (m.comment) commentsByPly.set(i, m.comment);
    });

    // keep chessMain at end
    chessMain.reset();
    modelMainSAN.forEach(s => chessMain.move(s));

    variationsByPly.clear();
    for (const [ply, list] of attached.entries()) {
      if (ply < 0) continue;
      list.forEach(sanTokens => {
        const v = { id: "v" + (varSeq++), san: sanTokens.slice() };
        if (!variationsByPly.has(ply)) variationsByPly.set(ply, []);
        variationsByPly.get(ply).push(v);
      });
    }

    activeVar = null;
    navPly = modelMainSAN.length - 1;

    setNavButtonsEnabled(modelMainSAN.length > 0);
    setBoard(navPly >= 0 ? fenAtMainPly(navPly) : "start", false);

    renderMoveList();
    // normalize textarea (ensures valid STR headers and ordering)
    syncTextareaFromModel();
  }

  // --- Move list rendering + "+ comment" button on last move ---
  function clearHighlights() {
    document.querySelectorAll(".move").forEach(el => el.classList.remove("active"));
  }

  function highlightMainPly(ply) {
    clearHighlights();
    const el = document.querySelector(`.move[data-main-ply="${ply}"]`);
    if (el) el.classList.add("active");
  }

  function renderMoveList() {
    movesDiv.innerHTML = "";

    // Use chess.js to derive SAN (and move numbers) cleanly for display
    const c = new Chess();
    const verbose = [];
    for (const san of modelMainSAN) {
      const mv = c.move(san);
      if (mv) verbose.push(mv);
    }

    verbose.forEach((m, i) => {
      const span = document.createElement("span");
      span.className = "move";
      span.dataset.mainPly = String(i);
      span.textContent = (m.color === "w" ? `${Math.floor(i/2)+1}. ` : "") + figSAN(m.san) + " ";
      span.onclick = () => {
        activeVar = null;
        navPly = i;
        setBoard(fenAtMainPly(navPly), true); // animate on navigation
        highlightMainPly(navPly);
      };
      movesDiv.appendChild(span);

      const cm = commentsByPly.get(i);
      if (cm && cm.trim()) {
        const cd = document.createElement("div");
        cd.className = "comment";
        cd.textContent = cm;
        movesDiv.appendChild(cd);
      }

      const vars = variationsByPly.get(i);
      if (vars && vars.length) {
        vars.forEach(v => {
          const vDiv = document.createElement("div");
          vDiv.className = "variation";

          const vc = new Chess();
          for (let k = 0; k <= i; k++) vc.move(modelMainSAN[k]);

          v.san.forEach((san, j) => {
            const moveObj = vc.move(san);
            if (!moveObj) return;

            const s = document.createElement("span");
            s.className = "move";
            s.textContent = figSAN(moveObj.san);
            s.onclick = () => {
              activeVar = { fromPly: i, varId: v.id, plyInVar: j };
              navPly = i;
              setBoard(vc.fen(), true);
              clearHighlights();
            };

            vDiv.appendChild(s);
            vDiv.appendChild(document.createTextNode(" "));
          });

          movesDiv.appendChild(vDiv);
        });
      }
    });

    // Plus button at end of the last move (mainline last ply)
    if (modelMainSAN.length > 0) {
      const plus = document.createElement("button");
      plus.className = "add-comment-btn";
      plus.title = "Add comment to last move";
      plus.type = "button";
      plus.textContent = "+";
      plus.onclick = () => {
        const lastPly = modelMainSAN.length - 1;
        const existing = commentsByPly.get(lastPly) || "";
        const txt = prompt("Comment for the last move (PGN {...}):", existing);
        if (txt === null) return; // cancelled
        const clean = String(txt).trim();
        if (!clean) commentsByPly.delete(lastPly);
        else commentsByPly.set(lastPly, clean);
        syncTextareaFromModel();
        renderMoveList();
      };
      movesDiv.appendChild(plus);
    }

    if (!activeVar) highlightMainPly(navPly);
  }

  // --- Move entry: append or create variation ---
  function onDrop(from, to) {
    // DO NOT animate for user-entered moves
    const base = new Chess();

    if (activeVar) {
      for (let i = 0; i <= activeVar.fromPly; i++) base.move(modelMainSAN[i]);
      const vlist = variationsByPly.get(activeVar.fromPly) || [];
      const v = vlist.find(x => x.id === activeVar.varId);
      if (v) for (let j = 0; j <= activeVar.plyInVar; j++) base.move(v.san[j]);
    } else {
      for (let i = 0; i <= navPly; i++) if (i >= 0) base.move(modelMainSAN[i]);
    }

    const move = base.move({ from, to, promotion: "q" });
    if (!move) return "snapback";

    const atMainEnd = (!activeVar && navPly === modelMainSAN.length - 1);

    if (atMainEnd) {
      modelMainSAN.push(move.san);
      navPly = modelMainSAN.length - 1;
      activeVar = null;

      chessMain.reset();
      modelMainSAN.forEach(s => chessMain.move(s));

      setBoard(chessMain.fen(), false);
      setNavButtonsEnabled(modelMainSAN.length > 0);
      syncTextareaFromModel();
      renderMoveList();
      return;
    }

    // not at end => add/continue variation
    if (activeVar) {
      const vlist = variationsByPly.get(activeVar.fromPly) || [];
      const v = vlist.find(x => x.id === activeVar.varId);
      if (v) {
        v.san.push(move.san);
        activeVar.plyInVar = v.san.length - 1;
      }
    } else {
      const branchFromPly = navPly;
      const v = { id: "v" + (varSeq++), san: [move.san] };
      if (!variationsByPly.has(branchFromPly)) variationsByPly.set(branchFromPly, []);
      variationsByPly.get(branchFromPly).push(v);
      activeVar = { fromPly: branchFromPly, varId: v.id, plyInVar: 0 };
    }

    setBoard(base.fen(), false);
    setNavButtonsEnabled(modelMainSAN.length > 0);
    syncTextareaFromModel();
    renderMoveList();
  }

  // --- Navigation (buttons + keyboard) ANIMATE ---
  function goStart() {
    activeVar = null;
    navPly = -1;
    setBoard("start", true);
    renderMoveList();
  }

  function goEnd() {
    activeVar = null;
    navPly = modelMainSAN.length - 1;
    setBoard(navPly >= 0 ? fenAtMainPly(navPly) : "start", true);
    renderMoveList();
  }

  function goPrev() {
    activeVar = null;
    if (modelMainSAN.length === 0) return;
    navPly = Math.max(-1, navPly - 1);
    setBoard(navPly >= 0 ? fenAtMainPly(navPly) : "start", true);
    renderMoveList();
  }

  function goNext() {
    activeVar = null;
    if (modelMainSAN.length === 0) return;
    navPly = Math.min(modelMainSAN.length - 1, navPly + 1);
    setBoard(fenAtMainPly(navPly), true);
    renderMoveList();
  }

  btnStart.onclick = goStart;
  btnPrev.onclick  = goPrev;
  btnNext.onclick  = goNext;
  btnEnd.onclick   = goEnd;

  document.addEventListener("keydown", (e) => {
    const active = document.activeElement;
    const typing = active && (active.tagName === "TEXTAREA" || active.tagName === "INPUT");
    if (typing) return;

    if (e.key === "Home") { e.preventDefault(); goStart(); }
    else if (e.key === "End") { e.preventDefault(); goEnd(); }
    else if (e.key === "ArrowLeft") { e.preventDefault(); goPrev(); }
    else if (e.key === "ArrowRight") { e.preventDefault(); goNext(); }
  });

  // --- Tabs (jQuery) ---
  $(".tab").on("click", function() {
    $(".tab,.pane").removeClass("active");
    $(this).addClass("active");
    $("#" + $(this).data("tab") + "Pane").addClass("active");
  });

  // --- COPY buttons (fixed to your exact request) ---
  // Copy PGN copies ALL text in textarea
  btnCopyPGN.onclick = () => writeClipboard(pgnText.value);

  // Copy FEN copies the FEN of the position currently on the board
  btnCopyFEN.onclick = () => writeClipboard(currentBoardFEN);

  // --- Add header dropdown ---
  btnAddTag.onclick = () => {
    const name = tagSelect.value;
    if (!name) return;
    if (!(name in tags)) {
      // Fill sensible defaults
      if (name === "Date") tags[name] = todayYYYYMMDD();
      else if (name === "Result") tags[name] = "*";
      else if (["Event","Site","Round","White","Black"].includes(name)) tags[name] = DEFAULT_TAGS[name] ?? "?";
      else if (name === "SetUp") tags[name] = "0";
      else tags[name] = "";
      tags = normalizeTags(tags);
      syncTextareaFromModel();
    }
    // Put cursor on the tag line (nice UX)
    const needle = `[${name} "`;
    const idx = pgnText.value.indexOf(needle);
    if (idx >= 0) {
      pgnText.focus();
      pgnText.setSelectionRange(idx + needle.length, idx + needle.length);
    }
  };

  // --- PGN editor: on blur, re-parse / normalize ---
  pgnText.onblur = () => loadFromTextarea();

  // --- Initial state (valid STR headers + empty game) ---
  tags = normalizeTags(DEFAULT_TAGS);
  modelMainSAN = [];
  variationsByPly.clear();
  commentsByPly.clear();
  activeVar = null;
  navPly = -1;

  syncTextareaFromModel();
  setNavButtonsEnabled(false);
  setBoard("start", false);
  renderMoveList();

  window.addEventListener("resize", () => board.resize());
})();
</script>

</body>
</html>
