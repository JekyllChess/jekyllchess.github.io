<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>JekyllChess PGN App</title>

<!-- jQuery REQUIRED by chessboard.js -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<!-- Chess libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">

<style>
*{box-sizing:border-box}
body{
  margin:0;
  background:#0f1115;
  color:#e6e6e6;
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
}
.top{
  padding:10px 14px;
  background:#171a21;
  border-bottom:1px solid #222;
  display:flex;
  align-items:center;
  gap:10px;
}
.top img{width:22px;height:22px;filter:invert(1)}
.top .title{font-weight:700}

.wrap{padding:12px}
.main{display:grid;grid-template-columns:1fr;gap:12px}
@media(min-width:900px){.main{grid-template-columns:560px 1fr}}
#board{width:min(92vw,560px);margin:0 auto}

.controls{
  width:min(92vw,560px);
  margin:10px auto 0;
  display:flex;
  gap:6px;
}
.controls button{
  flex:1;
  padding:10px 0;
  border:none;
  border-radius:10px;
  background:#1f2430;
  color:#ddd;
  cursor:pointer;
  font-size:15px;
}
.controls button:disabled{opacity:.4;cursor:default}

.card{
  border:1px solid #222;
  border-radius:12px;
  overflow:hidden;
  background:#0f1115;
}
.cardHead{
  padding:10px 12px;
  background:#141820;
  border-bottom:1px solid #222;
  font-weight:700;
}
.cardBody{padding:12px}

.moves{font-size:18px;line-height:2.05;word-break:break-word}
.move{
  display:inline-block;
  padding:2px 6px;
  border-radius:7px;
  cursor:pointer;
  user-select:none;
}
.move:hover{background:#20263a}
.move.active{background:#3a7afe;color:#fff}

.variation{
  margin:6px 0 10px 26px;
  padding-left:10px;
  border-left:2px dashed #444;
  opacity:.95;
}

/* Tooltip */
#pop{
  position:fixed;
  z-index:9999;
  background:#0b0f18;
  border:1px solid #2a3350;
  border-radius:12px;
  box-shadow:0 16px 50px rgba(0,0,0,.55);
  padding:8px;
  display:none;
  min-width:170px;
}
#pop .row{display:flex;gap:8px;align-items:center}
.popBtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:36px;
  height:36px;
  border-radius:10px;
  border:none;
  background:#1f2430;
  color:#e6e6e6;
  cursor:pointer;
  font-size:18px;
}
.popBtn:hover{background:#2a3150}
.popInputRow{display:flex;gap:8px;margin-top:8px}
.popInputRow input{
  flex:1;
  border-radius:10px;
  border:1px solid #2a3350;
  background:#0f1115;
  color:#e6e6e6;
  padding:10px;
  font-size:14px;
}
.popSave{
  width:44px;
  height:42px;
  border-radius:10px;
  border:none;
  background:#3a7afe;
  color:#fff;
  cursor:pointer;
  font-size:16px;
}
.popPieces{display:flex;gap:8px}
.popPieceBtn{
  flex:1;
  height:44px;
  border-radius:12px;
  border:1px solid #2a3350;
  background:#121724;
  color:#e6e6e6;
  cursor:pointer;
  font-size:22px;
}
.popPieceBtn:hover{background:#1b2340}
.popLabel{font-size:12px;opacity:.75;margin:6px 2px 0}
</style>
</head>

<body>

<div class="top">
  <img src="https://jekyllchess.github.io/assets/favicon.png" alt="">
  <div class="title">JekyllChess PGN App</div>
</div>

<div class="wrap">
  <div class="main">
    <div>
      <div id="board"></div>
      <div class="controls">
        <button id="btnStart" type="button">‚èÆ</button>
        <button id="btnPrev"  type="button">‚óÄ</button>
        <button id="btnNext"  type="button">‚ñ∂</button>
        <button id="btnEnd"   type="button">‚è≠</button>
      </div>
    </div>

    <div class="card">
      <div class="cardHead">Move list</div>
      <div class="cardBody">
        <div id="moves" class="moves"></div>
      </div>
    </div>
  </div>
</div>

<div id="pop"></div>

<script>
(() => {
  const FIG = { K:"‚ôî", Q:"‚ôï", R:"‚ôñ", B:"‚ôó", N:"‚ôò" };
  const figSAN = (s) => (s||"")
    .replace(/^[KQRBN]/, p => FIG[p] || p)
    .replace(/=([QRBN])/g, (_,p)=>"="+(FIG[p]||p));

  // ---------- Tree ----------
  let NODE_SEQ = 1;
  class Node {
    constructor(san=null, parent=null){
      this.id = "n" + (NODE_SEQ++);
      this.san = san;
      this.parent = parent;
      this.next = null;   // mainline continuation
      this.vars = [];     // variation roots (first move of each variation)
      this.comment = "";  // comment after move
    }
  }

  const root = new Node(null, null);
  let cursor = root;

  // Mainline navigation pointer (null = start position)
  let navNode = null;

  // ---------- Chess + Board ----------
  const chess = new Chess();

  const board = Chessboard("board", {
    position: "start",
    draggable: true,
    pieceTheme: "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png",
    onDrop: onDrop
  });

  function rebuildToNode(target, animate){
    chess.reset();
    if(!target || target === root){
      board.position("start", !!animate);
      return;
    }
    const chain = [];
    let n = target;
    while(n && n !== root){ chain.push(n); n = n.parent; }
    chain.reverse();
    for(const mv of chain) chess.move(mv.san);
    board.position(chess.fen(), !!animate);
  }

  function isOnMainline(node){
    let n = root.next;
    while(n){ if(n === node) return true; n = n.next; }
    return false;
  }

  function mainlineArray(){
    const arr = [];
    let n = root.next;
    while(n){ arr.push(n); n = n.next; }
    return arr;
  }

  function navIndex(){
    if(!navNode) return -1;
    const arr = mainlineArray();
    return arr.findIndex(x => x === navNode);
  }

  // ---------- Promotion (KEEP THIS WORKING FLOW) ----------
  const pop = document.getElementById("pop");
  let pendingPromotionFen = null;
  let pendingPromotionMove = null; // {from,to}

  function hidePop(){
    pop.style.display = "none";
    pop.innerHTML = "";
    pendingPromotionMove = null;
  }

  // keep pop open when interacting
  pop.addEventListener("mousedown", (e)=>e.stopPropagation());
  pop.addEventListener("click", (e)=>e.stopPropagation());
  document.addEventListener("mousedown", ()=>hidePop());

  function placePopCenterBoard(){
    const r = document.getElementById("board").getBoundingClientRect();
    pop.style.left = (r.left + r.width/2) + "px";
    pop.style.top  = (r.top  + r.height/2) + "px";
    pop.style.transform = "translate(-50%,-50%)";
  }

  function placePopNear(el){
    const r = el.getBoundingClientRect();
    const x = r.left + r.width/2;
    const y = r.top;
    pop.style.left = x + "px";
    pop.style.top  = (y - 10) + "px";
    pop.style.transform = "translate(-50%,-100%)";
  }

  function openPromotion(from, to){
    pop.innerHTML = `
      <div class="popLabel" style="margin:0 2px 6px;">Promote to</div>
      <div class="popPieces">
        <button class="popPieceBtn" data-p="q" title="Queen">‚ôï</button>
        <button class="popPieceBtn" data-p="r" title="Rook">‚ôñ</button>
        <button class="popPieceBtn" data-p="b" title="Bishop">‚ôó</button>
        <button class="popPieceBtn" data-p="n" title="Knight">‚ôò</button>
      </div>
      <div class="popLabel">Esc to cancel</div>
    `;
    pendingPromotionMove = {from, to};
    placePopCenterBoard();
    pop.style.display = "block";

    pop.querySelectorAll(".popPieceBtn").forEach(btn=>{
      btn.addEventListener("click",(e)=>{
        e.stopPropagation();
        commitPromotion(btn.getAttribute("data-p"));
      });
    });
  }

  function commitPromotion(p){
    if(!pendingPromotionMove) { hidePop(); return; }

    // DO NOT change this mechanism: load fen-before + apply chosen promotion
    chess.load(pendingPromotionFen);
    const m = chess.move({ from: pendingPromotionMove.from, to: pendingPromotionMove.to, promotion: p });
    if(!m){ hidePop(); return; }

    addMoveToTree(m.san);
    hidePop();

    rebuildToNode(cursor, false);
    render();
  }

  document.addEventListener("keydown",(e)=>{
    if(pop.style.display !== "none" && e.key === "Escape"){
      hidePop();
    }
  });

  // ---------- Variation-correct insertion ----------
  function addMoveToTree(san){
    // continue mainline if same
    if(cursor.next && cursor.next.san === san){
      cursor = cursor.next;
      if(isOnMainline(cursor)) navNode = cursor;
      return;
    }
    // continue an existing variation if same
    const existingVar = cursor.vars.find(v => v.san === san);
    if(existingVar){
      cursor = existingVar;
      return;
    }
    // create new node
    const n = new Node(san, cursor);

    // if mainline exists and differs => branch into variation
    if(cursor.next){
      cursor.vars.push(n);
    }else{
      cursor.next = n;
    }

    cursor = n;
    if(isOnMainline(cursor)) navNode = cursor;
  }

  // ---------- Tooltip-based move actions ----------
  function openMoveActions(node, anchorEl){
    pop.innerHTML = "";

    const row = document.createElement("div");
    row.className = "row";

    // Promote to mainline only if this node is a variation root under its parent
    const parent = node.parent;
    const isVarRoot = parent && parent !== root && parent.vars.some(v => v === node);

    if(isVarRoot){
      const up = document.createElement("button");
      up.className = "popBtn";
      up.textContent = "‚¨Ü";
      up.title = "Promote variation to mainline";
      up.onclick = (e)=>{
        e.stopPropagation();
        promoteVariation(parent, node);
        hidePop();
        render();
        rebuildToNode(cursor, false);
      };
      row.appendChild(up);
    }

    const plus = document.createElement("button");
    plus.className = "popBtn";
    plus.textContent = "Ôºã";
    plus.title = "Add comment after move";
    plus.onclick = (e)=>{
      e.stopPropagation();
      pop.innerHTML = "";
      const box = document.createElement("div");
      box.className = "popInputRow";

      const input = document.createElement("input");
      input.value = node.comment || "";
      input.placeholder = "Short comment‚Ä¶";
      input.addEventListener("mousedown",(ev)=>ev.stopPropagation());
      input.addEventListener("click",(ev)=>ev.stopPropagation());

      const save = document.createElement("button");
      save.className = "popSave";
      save.textContent = "‚úì";
      save.title = "Save";
      const doSave = ()=>{
        node.comment = (input.value||"").replace(/\}/g,"").trim();
        hidePop();
        render();
      };
      save.onclick = (ev)=>{ ev.stopPropagation(); doSave(); };
      input.onkeydown = (ev)=>{
        if(ev.key === "Enter"){ ev.preventDefault(); doSave(); }
        if(ev.key === "Escape"){ ev.preventDefault(); hidePop(); }
      };

      box.appendChild(input);
      box.appendChild(save);
      pop.appendChild(box);

      placePopNear(anchorEl);
      pop.style.display = "block";
      input.focus();
    };
    row.appendChild(plus);

    const del = document.createElement("button");
    del.className = "popBtn";
    del.textContent = "üóë";
    del.title = "Delete move (and continuation in that branch)";
    del.onclick = (e)=>{
      e.stopPropagation();
      deleteNode(node);
      hidePop();
      render();
      rebuildToNode(cursor, true);
    };
    row.appendChild(del);

    pop.appendChild(row);
    placePopNear(anchorEl);
    pop.style.display = "block";
  }

  function promoteVariation(parent, vNode){
    // swap parent.next with vNode (vNode must be in parent.vars)
    parent.vars = parent.vars.filter(x => x !== vNode);
    const oldMain = parent.next;
    parent.next = vNode;

    if(oldMain){
      parent.vars.unshift(oldMain);
      oldMain.parent = parent;
    }
    vNode.parent = parent;

    // if cursor is on old mainline subtree, its parent pointers still valid
    // navNode will be recomputed by clicks/navigation
  }

  function deleteNode(node){
    const parent = node.parent;
    if(!parent) return;

    if(parent.next === node){
      parent.next = null;
    }else{
      parent.vars = parent.vars.filter(v => v !== node);
    }

    cursor = parent;
    if(isOnMainline(cursor)) navNode = cursor; else navNode = null;
  }

  // ---------- Rendering (and click-to-rebuild FIX) ----------
  const movesDiv = document.getElementById("moves");

  function render(){
    movesDiv.innerHTML = "";

    function line(startNode, ply){
      let n = startNode.next;
      let localPly = ply;

      while(n){
        const isWhite = (localPly % 2 === 0);
        const moveNo = Math.floor(localPly/2) + 1;

        const span = document.createElement("span");
        span.className = "move" + (n === cursor ? " active" : "");
        span.textContent = (isWhite ? `${moveNo}. ` : "") + figSAN(n.san) + " ";
        span.dataset.nodeId = n.id;

        // CRITICAL: rebuild to clicked node (no extra state changes before rebuild)
        span.onclick = (e)=>{
          e.stopPropagation();
          cursor = n;
          if(isOnMainline(n)) navNode = n;
          rebuildToNode(n, true);
          render();
          openMoveActions(n, span);
        };

        movesDiv.appendChild(span);

        // comment display
        if(n.comment && n.comment.trim()){
          const c = document.createElement("div");
          c.style.margin = "4px 0 10px 18px";
          c.style.padding = "6px 8px";
          c.style.borderLeft = "3px solid #3a7afe";
          c.style.borderRadius = "8px";
          c.style.background = "#121724";
          c.style.color = "#cfd6ff";
          c.style.fontSize = "14px";
          c.textContent = n.comment;
          movesDiv.appendChild(c);
        }

        // variations after this move
        if(n.vars.length){
          n.vars.forEach(vRoot=>{
            const vDiv = document.createElement("div");
            vDiv.className = "variation";
            movesDiv.appendChild(vDiv);

            // render variation as its own line starting at vRoot (then vRoot.next...)
            // We need a small local renderer that prints vRoot as first move.
            function renderVarLine(varNode, varPly){
              let cur = varNode;
              let p = varPly;

              while(cur){
                const w = (p % 2 === 0);
                const mn = Math.floor(p/2) + 1;

                const sp = document.createElement("span");
                sp.className = "move" + (cur === cursor ? " active" : "");
                sp.textContent = (w ? `${mn}. ` : "") + figSAN(cur.san) + " ";
                sp.onclick = (e)=>{
                  e.stopPropagation();
                  cursor = cur;
                  // navNode unchanged if variation
                  rebuildToNode(cur, true);
                  render();
                  openMoveActions(cur, sp);
                };
                vDiv.appendChild(sp);

                if(cur.comment && cur.comment.trim()){
                  const cc = document.createElement("div");
                  cc.style.margin = "4px 0 10px 18px";
                  cc.style.padding = "6px 8px";
                  cc.style.borderLeft = "3px solid #3a7afe";
                  cc.style.borderRadius = "8px";
                  cc.style.background = "#121724";
                  cc.style.color = "#cfd6ff";
                  cc.style.fontSize = "14px";
                  cc.textContent = cur.comment;
                  vDiv.appendChild(cc);
                }

                // nested variations
                if(cur.vars.length){
                  cur.vars.forEach(nv=>{
                    const nvDiv = document.createElement("div");
                    nvDiv.className = "variation";
                    vDiv.appendChild(nvDiv);

                    // recurse nested
                    const savedDiv = vDiv;
                    const saved = vDiv;
                    // easiest: temporary closure using same helper but with target div
                    (function renderNestedLine(targetDiv, nodeStart, plyStart){
                      let nn = nodeStart;
                      let pp = plyStart;
                      while(nn){
                        const ww = (pp % 2 === 0);
                        const mm = Math.floor(pp/2) + 1;
                        const ssp = document.createElement("span");
                        ssp.className = "move" + (nn === cursor ? " active" : "");
                        ssp.textContent = (ww ? `${mm}. ` : "") + figSAN(nn.san) + " ";
                        ssp.onclick = (e)=>{
                          e.stopPropagation();
                          cursor = nn;
                          rebuildToNode(nn, true);
                          render();
                          openMoveActions(nn, ssp);
                        };
                        targetDiv.appendChild(ssp);
                        nn = nn.next;
                        pp++;
                      }
                    })(nvDiv, nv, p+1);
                  });
                }

                // continue along variation mainline
                cur = cur.next;
                p++;
              }
            }

            renderVarLine(vRoot, localPly + 1);
          });
        }

        n = n.next;
        localPly++;
      }
    }

    line(root, 0);
    updateNavButtons();
  }

  // ---------- Navigation (FIXED disable logic + keyboard) ----------
  const btnStart = document.getElementById("btnStart");
  const btnPrev  = document.getElementById("btnPrev");
  const btnNext  = document.getElementById("btnNext");
  const btnEnd   = document.getElementById("btnEnd");

  function goStart(){
    navNode = null;
    cursor = root;
    rebuildToNode(root, true);
    render();
  }

  function goEnd(){
    const arr = mainlineArray();
    if(!arr.length){ goStart(); return; }
    navNode = arr[arr.length-1];
    cursor = navNode;
    rebuildToNode(cursor, true);
    render();
  }

  function goPrev(){
    const arr = mainlineArray();
    const i = navIndex();
    if(i <= -1){ return; } // already at start
    if(i === 0){
      goStart();
      return;
    }
    navNode = arr[i-1];
    cursor = navNode;
    rebuildToNode(cursor, true);
    render();
  }

  function goNext(){
    const arr = mainlineArray();
    if(!arr.length) return;
    const i = navIndex();
    if(i === -1){
      navNode = arr[0];
    }else{
      navNode = arr[Math.min(arr.length-1, i+1)];
    }
    cursor = navNode;
    rebuildToNode(cursor, true);
    render();
  }

  function updateNavButtons(){
    const arr = mainlineArray();
    const i = navIndex();
    const has = arr.length > 0;

    // at start: i === -1
    btnStart.disabled = !has || i === -1;
    btnPrev.disabled  = !has || i === -1;

    // at end: i === arr.length-1
    btnEnd.disabled   = !has || i === arr.length-1;
    btnNext.disabled  = !has || i === arr.length-1;
  }

  btnStart.onclick = (e)=>{ e.stopPropagation(); hidePop(); goStart(); };
  btnPrev.onclick  = (e)=>{ e.stopPropagation(); hidePop(); goPrev(); };
  btnNext.onclick  = (e)=>{ e.stopPropagation(); hidePop(); goNext(); };
  btnEnd.onclick   = (e)=>{ e.stopPropagation(); hidePop(); goEnd(); };

  // Keyboard: call functions directly (NOT .click()), so it works even if buttons are disabled
  document.addEventListener("keydown",(e)=>{
    const active = document.activeElement;
    const typing = active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA");
    if(typing) return;
    if(pop.style.display !== "none") return;

    if(e.key === "ArrowLeft"){ e.preventDefault(); goPrev(); }
    else if(e.key === "ArrowRight"){ e.preventDefault(); goNext(); }
  });

  // ---------- Drop handler (promotion preserved) ----------
  function onDrop(from, to){
    hidePop();

    const test = new Chess(chess.fen());
    const mQ = test.move({ from, to, promotion:"q" });
    if(!mQ) return "snapback";

    // KEEP THIS: promotion detection + snapback + popup
    if(mQ.flags && mQ.flags.includes("p")){
      pendingPromotionFen = chess.fen();
      openPromotion(from, to);
      return "snapback";
    }

    const m = chess.move({ from, to, promotion:"q" });
    if(!m) return "snapback";

    addMoveToTree(m.san);
    rebuildToNode(cursor, false);
    render();
  }

  // ---------- Init ----------
  render();
  rebuildToNode(root, false);
  window.addEventListener("resize", ()=>board.resize());
})();
</script>

</body>
</html>
